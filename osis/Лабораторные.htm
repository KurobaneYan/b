<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
	<title>ОСИС, лабораторные</title>
	<meta http-equiv="content-type" content="text/html;charset=utf-8" />
	<meta name="generator" content="Geany 0.19.2" />
</head>

<body>
    <h1></h1>
    <hr/>

    <h2>Л/р №1 :  "Ознакомление с инструментарием программиста под Unix" [2]</h2>
    <p>Изучить утилиты: cc, c++, cpp. Написать классическую программу "Hello world", скомпилировать её в выходную программу двумя способами: непосредственное формирование выходной программы из исходного кода и опосредованное .o-файлом.
    </p>
    <hr/>


    <h2>Л/р №2 :  "Основы программирования на C под Unix" [4-6]</h2>
    <p>Задания выполняются с использованием как библиотек, так и, возможно, вызовов внешних программ. Ограничений на создание временных файлов не налагается, но желательно этого избегать.
    </p>
    <ol>
        <li>Программа-фильтр -- инверсия порядка байт в потоке (первый -- последний, второй -- предпоследний, и т.д.).</li>
        <li>Программа-фильтр -- инверсия порядка строк потока (предполагается, что поток -- текст, состоящий из отдельных строк). Длину строк можно считать ограниченной некоторой константой.</li>
        <li>Программа-фильтр -- инверсия порядка символов в каждой строке потока, порядок самих строк не изменяется. Длину строк можно считать ограниченной некоторой константой.</li>
        <li>Проверка и коррекция текста по словарю. Проверка производится на совпадение, без анализа словоформ; корректировать достаточно одиночные ошибки. Программа оформляется как фильтр, словарь -- внешний файл, его размер заранее не известен.</li>
        <li>Проверка и "цензура" текста: удаление (замена фиксированным шаблоном) "запрещенных" слов, заданных словарем. Проверка на совпадение, без анализа словоформ. Программа оформляется как фильтр, словарь -- внешний файл, его размер заранее не известен.</li>
        <li>Программа -- "записная книжка". Режим работы -- командная строка (программа вызывается на 1 операцию, задаваемую аргументами командной строки, после его исполнения управление возвращается в shell. База данных -- текстовый файл, записи включают несколько полей (формат выбирается произвольно). Операции: добавление, удаление, поиск (по различным полям) и отображение, изменение записи.</li>
        <li>Программа -- "записная книжка". Аналогично, но режим работы интерактивный (диалоговый): ввод команды, исполнение, ожидание следующей.</li>
        <li>Программа-фильтр -- преобразование символов в комбинации азбуки Морзе. Непреобразуемые символы отбрасываются.</li>
        <li>Программа-фильтр -- преобразование комбинаций азбуки Морзе в печатные символы.</li>
        <li>Программа -- криптографический фильтр: шифрование и дешифрование потока. Криптоалгоритм выбирается произвольно (можно простейшие). Способ передачи пароля и других параметров шифрования выбирается произвольно. (В случае достаточно сложного криптоалгоритма задание раздивается на 2: прямое и обратное преобразование.).</li>
    </ol>
    <hr/>

    <h2>Л/р №3 :  "Изучение утилиты make" [2]</h2>
    <p>Разбить программу, разработанную в предыдущей л/р на несколько модулей (как минимум на два: main.c и algorithm.c). Для управления обработкой проекта использовать утилита <em>make</em> (для которой нужно написать соответствующий <em>makefile</em>). В makefile должны быть следующие цели:
    </p>
        <ol>
            <li>Цель по сборке основной программы</li>
            <li>Цели по сборке модулей</li>
            <li>Цель для очистки проекта (clean)</li>
            <li>Цель для тестирования проекта. Нужно, чтобы прогонялось некоторое количество тестов. Каждый тест, например, состоит из входных данных (in.txt) и ожидаемых выходных данных (out-expected.txt). Запускается программа на входных данных; ее выход сохраняется в некотором файле (out.txt). Затем эмпирический полученный результат сравнивается (out.txt) с ожидаемым (out-expected.txt). Если результы совпадают, тест прошёл. Проект считается готовой, когда она проходит все тесты. </li>
        </ol>
    <hr/>


    <h2>Л/р №4 :  "Основы управления процессами в Unix. Программы-демоны." [6]</h2>
    <ol>
        <li>Создание программы-демона, которая "умеет" обрабатывать произвольные заданные сигналы. Обработка заключается в протоколировании сигнала (записи в файл номера сигнала, его символического имени и, например, времени его получения). Список контролируемых сигналов задается файлом конфигурации, который считывается демоном при старте и по сигналу SIGHUP (этот сигнал также может быть среди протоколируемых).</li>
        <li>Реализовать "блуждающий процесс". Запускается программа (1), которая через некоторое время запускает саму себя (2), т.е. делает fork(). Через некоторое время исходная программа (1) завершается, выводит свой идентификатор (pid, process id) и номер поколения. Программа должна клонировать себя с определённой скоростью, которая читается из файла. Для изменения значения скорости клонирования нужно написать другую программу-демона, которая будет принимать сигналы и увеличивать или уменьшать скорость клонирования.</li>
    </ol>
    <hr/>

    <h2>Л/р №5 :  "IPC : Использование именованных (pipe) и неименованных (FIFO) каналов." [6]</h2>
    <p>Написать программы (отдельные) или программу, порождающую в ходе выполнения дочение процессы; реализовать передачу данных между процессами, используя каналы (именованные или неименованные в зависимости от варианта); отладить многопроцессный программный комплекс. Процессы взаимодействуют друг с другом по принципу "клиент-сервер".
    </p>
    <ol>
        <li>Процесс-родитель порождает 3 дочерних процесса, каждому из которых он предоставляет собственный неименованный канал (pipe). Каждый из порожденных процессов (клиентов) передает родительскому (серверу) текстовые строки, например вводимые с консоли. Родительский процесс отображает присылаемые строки в порядке их поступления.
            <p>
                <em>Примечание</em>. Необходимо обеспечить передачу каждому порожденному процессу дескрипторов, соответствующих именного его "персональному" каналу, и одновременно возможность для родительского процесса контролировать все каналы.
            </p>
        </li>
        <li>Программа, поведение которой определяются именем исполняемого файла, из которого порожден процесс. Если имя server, то то процесс выполняет функции сервера: создает именованный канал (FIFO), принимает из него сообщения, выделяет из сообщений 2 числа x и y и возвращает в канал ответное сообщение, содержащее сумму x+y ("канальный сервер-калькулятор на одно действие"). Если имя файла другое, процесс выполняет функции клиента: вводит 2 числа с консоли, формирует сообщение, передает его в канал, ожидает ответного сообщения, отображает его на консоль.
            <p>
                 <em>Примечание</em>. Необходимо правильно организовать прием и передачу данных, чтобы минимизировать вероятность "подхвата" фрагментов, относящихся к разным сообщениям. Имя файла, из которого был порожен процесс, передается ему в виде первого по счету аргумента командной строки -- параметра argv[0] функции main() (программы на языке C); перед проверкой имя файла должно быть освобождено от возможно присутствующего пути.
            </p>
        </li>
        <li>
            Программа, автоматически определяющая свою функцию -- клиент или сервер -- по наличию коммуникационного ресурса: каждый экземпляр процесса производит поиск именованного канала (FIFO) с заранее известным именем. Если FIFO не найден, процесс создает его и начинает функционировать как сервер. Если FIFO найден, процесс открывает его и начинает функционировать как клиент. Функции сервера: занести в FIFO текущее время (формат можно выбирать произвольно) и ежесекундно его обновлять. Функции клиента: считывать текущее значения времени из FIFO и выводить его на консоль (однократно при запуске или в цикле).
            <p>
                <em>Примечание</em>. Со стороны клиента можно предусмотреть "неразрушающее" чтение -- например, немедленный возврат прочитанного значения в канал. Кроме того, клиент, вероятно, должен адекватно относиться к пустоте канала (ожидание при чтении из FIFO). В свою очередь, сервер обязан следить за постоянным наличием в канале одного и только одного (желательно правильного) значения текущего времени. Для этого требуется постоянно проверять FIFO на пустоту, а по истечении периода смены показаний удалять старое значение и записывать новое; одновременно сервер не должен блокироваться, если FIFO в этот момент окажется пустым. Вместо отдельной программы-клиена в процессе отладки можно использовать стандартные средства вывода содержимого файла (cat, копирование в /dev/tty); чтение в этом случае однозначно "разрушающее".
            </p>
        </li>
        <li>
            Программа -- генератор паролей. Аналогично предыдущему заданию, процесс автоматически определяет свою функцию: клиент или сервер. Сервер записывает в канал FIFO очередной сгенерированныйим пароль (алгоритм генерации и проверки паролей может быть выбиран произвольно) и ожидает опустошения канала, затем записывает новый пароль, и т.д. Клиент просто считывает пароль из FIFO и использует его (выводит на консоль), чтение обычное "разрушающее", т.к. клиент не заинтересован в повторном использовании этого же пароля другим процессом.
            <p>
                <em>Примечание</em>.  В целом аналогично предыдущему заданию. Необходимость обеспечить для сервера контроль текущего состояния канала и реагирование на его опустошение. В качестве усложняющего элемента можно потребовать от сервера периодическую смену пароля, находящегося в FIFO, если клиенты долго не забирают его оттуда.
            </p>
        </li>
    </ol>
    <hr/>

    <h2>Л/р №6 :  "IPC: Использование объектов System V : semaphore, messages, shared memory." [6]</h2>
        <h3>Теоретическая часть</h3>
        <p>Идентификация объектов, генерация ключа, группы функций. Набор объектов, называемых System V IPC, призван комплексно решить задачи, возникающие при взаимодействии процессов и включает 3 вида объектов:
        </p>
        <ul>
            <li>Semaphore -- семафор, используемый в первую очередь для синхронизации и защиты критических секций, отличается от классического тем, что является не только многозначным, но и векторным, то есть объединяет целую группу счетчиков-семафоров.</li>
            <li>Messages queue -- сообщения, точнее очередь сообщений, пригодных для передачи небольших порций данных в том числе и между процессами, а также для синхронизации. Сообщение характеризуется его типом, который представляется целым числом. Очередь обеспечивает выборку сообщений с группировкой по типу, что позволяет реализовать приоритеты сообщений.</li>
            <li>Shared memory -- разделяемая память, блок данных, который может быть отображен на адресное пространство более чем одного процесса одновременно. Это позволяет наиболее эффективно реализовать передачу значительных объемов информации между процессами, а также совместную их обработку, но одновременно может требовать дополнительных мер по защите от конфликтов (например, с помощью семафоров).</li>
        </ul>
        <p>Всем экземплярам объектов System V IPC сопоставлены целочисленные идентификаторы, относящиеся к трем независимым пространствам идентификаторов: соответственно семафоров, очередей сообщений и разделяемый блоков памяти, и не пересекающиеся с файловыми дескрипторами или любыми другими идентификаторами в системе. Объекты System V IPC не имеют имен, проблема их глобальной (между процессами, в том числе и не родственными друг другу) видимости решается использованием имен в файловой системе и специального промежуточного элемента -- ключа.</p>

        <h3>Практическая часть</h3>
        <p>Написать программы (программу, порождающую копии -- дочение процессы), взаимодействующие друг с другом посредством объектов System V IPC и образующие таким образом единый программный комплекс, реализующий функции в соответствии с вариантами задания.</p>
        <ol>
            <li>Копирование файла двумя параллельными процессами: один осуществляет чтение из файла-источника, второй -- запись в файл-приемник. Используются 2 независимых буфера: для чтения и для записи, которые меняются местами (передаются между процессами) по мере соответственно заполнения и опустошения. В качестве буферов используются блоки разделяемой памяти (shared memory), для синхронизации процессов и управления доступом к буферам -- семафоры (semaphore).
                <p><em>Примечание</em>. Различие скоростей чтения и записи может приводить к простоям процессов, что необходимо учесть: заполненный "буфер чтения" можно передать как "буфер записи" в распоряжение "процесса записи" независимо от его состояния, но "процесс чтения" все равно вынужден будет ждять освобождения бывшего "буфера записи", чтобы использовать его как "буфер чтения". Представляет интерес оценка эффекта от распараллеливания процессов, но заметной она будет лишь на больших размерах файлов и меделенных устройствах.
                </p>
            </li>
            <li>Усложненный вариант предыдущего задания: вместо 2 попеременно используемых буферов в блоках разделяемой памяти создается очередь блоков, что придает системе большую гибкость и большие возможности по выравниванию скоростей чтения и записи.</li>
            <li>Передача сообщений через разделяемую память: процесс-сервер последовательно извлекает сообщения из очереди, созданной в разделяемой памяти и выводит их в файл; процессы-клиенты вводят сообщения (текстовые) с консоли и передают в очередь. Используются объекты: буфер (очередь) для хранения передаваемых сообщений -- блок разделемой памяти (shared memory); семафоры (semaphore) для синхронизации и управления очередью
                <p><em>Примечание</em>.  Представляет интерес эксперимент с использованием в качестве передаваемых сообщений объектов -- сообщений SystemV IPC (messages): требуется ли размещать данные таких сообщений именно в разделяемой памяти.</p>
            </li>
            <li>Конвейерная обработка. В блоке разделяемой памяти (64 Кбайт), разбитой на подблоки (4 Кбайта каждый) 3 процесса выполняют последовательную обработку подблоков:
                <ol>
                    <li>генерирует случайное содержимое очередного подблока;</li>
                    <li>сортирует содержимое подблока (алгоритм может быть задан произвольным образом);</li>
                    <li>выводит содержимое подблоков по мере готовности.</li>
                </ol>
                <p><em>Примечание</em>. Для управления выделением и обработкой подблоков в shared memory потребуются семафоры (semaphore), наборы которых должны описывать все подблоки.</p>
            </li>
            <li>Параллельная обработка. Начальные условия аналогичны предыдущему заданию, но распредление функций процессов иное:
                <ul>
                    <li>1 -- генерирует случайное содержимое очередного свободного подблока;</li>
                    <li>2 и 3 -- реализуют сортировку блока различными алгоритмами.</li>
                </ul>
                <p>Процессы 2 и 3 конкурируют за возможность отсортировать заполненные блоки. Все процессы ведут статистику -- количество обработанных блоков -- для оценки сравнительной эффективности сортировки. </p>
                <p><em>Примечание</em>. Считается, что сортировкой обработка блока заканчивается, но с целью отладки может быть удобно выводить их содержимое на консоль.</p>
            </li>
            <li>Моделирование задачи об обедающих философах. Модель имитационная, в ней участвуют процессы: "философы" 1..5 и "слуга" ("диспетчер"), а также объекты, соответствующие "блюду" и "вилкам" 1..5. Функционирование каждого процесса-"философа" сводится к осуществлению "еды": процесс пытается последовательно завладеть двумя "вилками", с помощью которых может начать использовать "блюдо" (длительность пребывания в этом состоянии -- случайная величина), по окончании "еды" он так же последовательно освобождает обе "вилки"; при этом "философы" не "общаются" друг с другом и, следовательно, не могут "договориться" о согласованных действиях. Функции "слуги" могут быть разнообразны: от простой регистрации событий и ведения статистики модели до предупреждения и разрешения конфликтов.
                <p>Возможны подварианты модели:</p>
                <ul>
                    <li>фиксированный порядок захвата "вилок" "философами";</li>
                    <li>случайный выбор "вилки";</li>
                    <li>бесконечное ожидание "вилки";</li>
                    <li>тайм-аут ожидания (по истечении заданного времени "философ" обязан освободить уже взятую вилку);</li>
                    <li>различные законы (параметры) распредления времени "еды";</li>
                    <li>участие слуги в управлении взаимодействием.</li>
                </ul>
                <p>Возможны подварианты задания:</p>
                <ul>
                    <li>сбор и затем вывод статистики модели, останов сеанса по времени;</li>
                    <li>обнаружение тупика и прекращение сеанса моделирования;</li>
                    <li>предотвращение тупика силами "слуги".</li>
                </ul>
                <p><em>Примечание</em>. В данном случае для задачи не существенны сами объекты-ресурсы (критические и некритические), поэтому программная модель может не включать их. Достаточно только объектов, отвечающих за синхронизацию и управление доступом, т.е. семафоров (либо иных, используемых для этой цели).</p>
            </li>
        </ol>
    <hr/>

    <h2>Л/р №7 :  "IPC: Использование сокетов." [6]</h2>
    <p>Создать программу-сервер, реализующие протокол реальной сетевой службы или собственный; как правило, серверы выполняются в режиме демона. При необходимости создаются также вспомогательные программы, например, клиент для тестирования и демонстрации работоспособности сервера. </p>
    <p><em>Примечание</em>. В качестве "универсального" клиента для протокола TCP можно использовать программу telnet.</p>
    <ol>
        <li>"Сервер морзянки" -- прямое преобразование. Программа-демон, поддерживает соединения TCP, преобразует принимаемый текст в знаки азбуки Морзе. Номер базового порта TCP задается как параметр командной строки </li>
        <li>"Сервер морзянки" -- обратное преобразование. Аналогично предыдущему, но выполняется преобразование из знаков азбуки Морзе в обычный текст. </li>
        <li>Сервис date (daytime). Программа-демон, реализующая сервер указанной службы с поддержкой протоколов TCP и UDP (порт номер 13): в ответ на обращение выдает текущие дату и время. Подробности см. в RFC867</li>
        <li>Сервис echo. Программа-демон, реализующая сервер указанной службы с поддержкой протоколов TCP и UDP (порт номер 7): любое полученное сообщение возвращается отправителю без изменений. Подробности см. в RFC347</li>
        <li>Сервис systat. Программа-демон, реализующая сервер указанной службы с поддержкой протоколов TCP и UDP (порт номер 11): в ответ на обращение выдает текущий список активных пользователей системы. Подробности см. в RFC866</li>
        <li>Сервис time. Программа-демон, реализующая сервер указанной службы с поддержкой протоколов TCP и UDP (порт номер 37): в ответ на обращение выдает текущее время в секундах, прошедших с 00:00 1.01.1900. Подробности см. в RFC868</li>
    </ol>
    <hr/>

    <h2>Л/р №8 :  "pthread: реализовать простейшей многопоточной программы." [8]</h2>
    <p>Создать программу-сервер, реализующие протокол реальной сетевой службы или собственный; программа должна выполняться в режиме демона. Сервер должен обслуживать параллельную обработку нескольких клиентов.</p>
    <ol>
        <li>Реализация простейшего HTTP-сервера, который отдаёт статические ресурсы</li>
        <li>Реализация простейшего FTP-сервера, реализующего возможность параллельного входа нескольких анонимных пользователей</li>
        <li>Реализация простейшего <em>многопоточного</em> HTTP-паука: программе-пауку передается начальный URL. По этому URL программа скачивает страничку, которую затем анализирует и вычленяет другие URL, встречающиеся в документе. Затем программа запрашивает вновь полученные URL в отдельных потоках. Максимальное количество потоков должно быть ограничено аргументом командной строки. В конце работы программа выдает статистику: количество скаченных байтов и средняя скорость скачивания.</li>
        <li>Реализация простейшего <em>многопоточного</em> FTP-паука: аналогично предыдущему, только осуществляется выкачивание всего FTP-сайта</li>
    </ol>
    <hr/>

    <h2>Л/р №9 :  "Использование fork() для реализации сервера" [8]</h2>
    <p>Создать программу-сервер, реализующие протокол реальной сетевой службы или собственный; программа должна выполняться в режиме демона. Сервер должен обслуживать параллельную обработку нескольких клиентов. В отличие от предыдущей программы, должен запускаться родительский процесс, который при входящем запросе осуществляет запуск дочернего процесса-обработчика запроса. При этом, родительский процесс "следить" за дочерними процессами (если их меньше определённого количества, то запускается дополнительный сервер-обработчик, если дочерний процесс долгое время не откликается, то родительский его уничтожает)</p>
    <ol>
        <li>Реализация простейшего HTTP-сервера, который отдаёт статические ресурсы</li>
        <li>Реализация простейшего FTP-сервера, реализующего возможность параллельного входа нескольких анонимных пользователей</li>
    </ol>
    <hr/>

    <h2>Л/р №10 :  "Использование Socket API в системе Windows." [4]</h2>
    <p>Портировать программу, написанную в ЛР №7 под ОС Windows. </p>
    <hr/>

    <h2>Л/р №11 :  "Pthread системе Windows." [4]</h2>
    <p>Портировать программу, написанную в ЛР №8 под ОС Windows, используя реализацию библиотеки pthread под Windows </p>
    <hr/>

</body>

</html>
